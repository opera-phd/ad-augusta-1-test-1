<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Thinking Knowledge Graph</title>
    <!-- Explicitly load Three.js first so 'THREE' is available globally for our custom node objects -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <!-- Load 3d-force-graph with https protocol -->
    <script src="https://unpkg.com/3d-force-graph@1.73.1/dist/3d-force-graph.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- BACKGROUND STRATEGY --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000000; 
            font-family: 'Inter', sans-serif;
            background-image: url('https://opera-phd.org/wp-content/uploads/2025/12/PKG-2-1920-black.jpg');
            background-size: cover; 
            background-repeat: no-repeat;
            background-position: center center;
        }
        
        #3d-graph { width: 100vw; height: 100vh; }
        
        /* Custom Scrollbar for the sidebar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1a1a2e; }
        ::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 3px; }

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 z-10 w-full h-full pointer-events-none flex flex-col justify-between p-6">
        
        <!-- Header Container (Top Left) -->
        <div class="pointer-events-auto max-w-md relative">
            
            <!-- 1. MAXIMIZED HEADER (Default) -->
            <div id="header-panel" class="glass-panel rounded-xl p-5 text-white mb-4 relative transition-all duration-300 origin-top-left">
                <!-- Minimize Button -->
                <button onclick="toggleHeader()" class="absolute top-3 right-3 text-gray-400 hover:text-white p-1 hover:bg-white/10 rounded transition cursor-pointer" title="Minimizează">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <!-- ================================-->
                <!-- infocard permanent, stânga, sus -->
                <!-- ================================-->
                <!-- ================================-->  
                <div class="flex items-center gap-3 mb-2 pr-6">
                    <div class="w-3 h-3 rounded-full bg-blue-500 animate-pulse"></div>
                    <h1 class="text-xl font-bold tracking-wide">Prezentare dinamică: Gândirea Vizuală</h1>
                </div>
                <p class="text-sm text-gray-400 leading-relaxed">
                    O reprezentare interactivă spațială a interpretării conceptului de „Extended Mind”, cu o scurtă privire asupra elementelor din evoluția gândirii vizuale. (prezentare în dezvoltare) 
                    <br><br>
                    <span class="text-blue-400 font-semibold">Instrucțiuni:</span> Faceți click pe orice nod pentru a investiga conexiunile dintre gândirea vizuală și sistemele de management al cunoașterii.
                    <br><br><hr>
                    <span class="block text-[10.5px] text-gray-400 leading-relaxed">
                        lect. dr. arh. Adrian Vidrașcu (în cadrul proiectului
                        <a
                        href="https://opera-phd.github.io/ad-augusta-1-test-1"
                        class="text-blue-400 hover:underline"
                        target="_blank"
                        rel="noopener noreferrer"
  >                     Ad Augusta
                        </a>
                        )
                    </span>
                </p>
            </div>

            <!-- 2. MINIMIZED HEADER (Hidden by default) -->
            <div id="header-minimized" class="hidden pointer-events-auto glass-panel rounded-full px-4 py-2 text-white items-center gap-2 cursor-pointer hover:bg-slate-800/90 transition-all origin-top-left" onclick="toggleHeader()">
                <div class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></div>
                <span class="text-sm font-bold font-mono">Info</span>
                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="ml-1">
                    <polyline points="15 3 21 3 21 9"></polyline>
                    <polyline points="9 21 3 21 3 15"></polyline>
                    <line x1="21" y1="3" x2="14" y2="10"></line>
                    <line x1="3" y1="21" x2="10" y2="14"></line>
                </svg>
            </div>

        </div>

        <!-- Sidebar / Info Card (Middle Left / Hidden by default) -->
        <div id="info-card" class="pointer-events-auto max-w-md transition-all duration-500 transform translate-x-[-120%] opacity-0 relative">
            <div class="glass-panel rounded-xl p-6 text-white border-l-4 border-blue-500 relative">
                
                <!-- CLOSE BUTTON (X) for Info Card -->
                <button onclick="closeInfoCard()" class="absolute top-3 right-3 text-gray-400 hover:text-white hover:bg-white/10 p-1.5 rounded-lg transition-colors z-20 cursor-pointer" title="Închide fereastra">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>

                <div class="flex justify-between items-start mb-4 pr-8">
                    <h2 id="card-title" class="text-2xl font-bold text-blue-100">Titlu Nod</h2>
                    <!-- Year Label: Removed opacity-80 class from text so it stays crisp white -->
                    <span id="card-year" class="text-xs font-mono px-2 py-1 rounded text-white mt-1 border border-white/10">19XX</span>
                </div>
                
                <div class="mb-4">
                    <h3 class="text-xs uppercase tracking-widest text-gray-500 mb-1">Concept Principal</h3>
                    <p id="card-concept" class="text-gray-200 font-medium text-lg">Conceptul apare aici.</p>
                </div>

                <div class="mb-4">
                    <h3 class="text-xs uppercase tracking-widest text-gray-500 mb-1">Argument Cheie</h3>
                    <p id="card-desc" class="text-sm text-gray-400 leading-relaxed">Descrierea.</p>
                </div>
                
                <div class="border-t border-gray-700 pt-3 mt-3">
                     <h3 class="text-xs uppercase tracking-widest text-gray-500 mb-2">Conexiuni</h3>
                     <div id="card-connections" class="flex flex-wrap gap-2">
                        <!-- Tags generated via JS -->
                     </div>
                </div>
            </div>
        </div>

        <!-- Footer Controls (Bottom Left) -->
        <div class="pointer-events-auto flex gap-3">
            <button onclick="resetCamera()" class="glass-panel px-4 py-2 rounded-lg text-white text-sm hover:bg-white/10 transition cursor-pointer font-mono">
                [ Resetarea graficului ]
            </button>
            <button onclick="toggleRotation()" class="glass-panel px-4 py-2 rounded-lg text-white text-sm hover:bg-white/10 transition cursor-pointer font-mono">
                [ Oprirea animației de rotație ]
            </button>
        </div>
    </div>

    <!-- The 3D Canvas -->
    <div id="3d-graph"></div>

    <script>
        // Wait for DOM and Scripts to load
        window.addEventListener('DOMContentLoaded', () => {
            
            // Check if libraries loaded correctly
            if (typeof ForceGraph3D === 'undefined' || typeof THREE === 'undefined') {
                document.getElementById('3d-graph').innerHTML = '<div class="text-white p-10">Eroare la încărcarea bibliotecilor 3D. Verifică conexiunea la internet.</div>';
                return;
            }

            // ================================
            // --- 1. The Knowledge Dataset ---
            // EDIT THIS SECTION TO ADD NODES
            // ================================
            const graphData = {
                nodes: [
                    { 
                        id: "Gândire vizuală", 
                        group: "Concept", 
                        year: "1969",
                        concept: "Percepția este cunoaștere",
                        desc: "Rudolf Arnheim a susținut că distincția dintre „a vedea” și „a gândi” este falsă. Gândim în forme și structuri, nu doar în cuvinte.",
                        val: 20 
                    },
                    { 
                        id: "Codare duală", 
                        group: "Concept", 
                        year: "1971",
                        concept: "Gândire = Verbal + Vizual",
                        desc: "Teoria lui Allan Paivio sugerează că mintea procesează informația prin două canale diferite: verbal și nonverbal, iar activarea lor împreună întărește procesele cognitive.",
                        val: 15 
                    },
                    { 
                        id: "Memex", 
                        group: "System", 
                        year: "1945",
                        concept: "Gândire asociativă",
                        desc: "Instrumentul ipotetic al lui Vannevar Bush, documentat în articolul său din 1945, „As We May Think”. El a susținut că mintea umană funcționează prin asocieri, nu prin indexare. Străbunicul hyperlink-ului.",
                        val: 25 
                    },
                    { 
                        id: "Zettelkasten", 
                        group: "System", 
                        year: "1960s",
                        concept: "Partener de conversație",
                        desc: "„Cutiile cu fișe” ale lui Niklas Luhmann, pe care acesta le considera un partener de cercetare. Prin conectarea notițelor „atomice”, sistemul este capabil să creeze conexiuni emergente în interacțiunea cu utilizatorul. Principalele componente sunt Literaturzettel, Folgezettel și registrul de indecși.",
                        val: 18 
                    },
                    { 
                        id: "Augmentarea gândirii", 
                        group: "Concept", 
                        year: "1962",
                        concept: "Co-evoluția instrument-sistem",
                        desc: "Douglas Engelbart propunea sistemul H-LAM/T (Human, Language, Artifacts, Methodology, Training). Metodele și instrumentele se îmbunătățesc reciproc și extind capacitatea gândirii umane.",
                        val: 20 
                    },
                    { 
                        id: "Dynabook", 
                        group: "System", 
                        year: "1972",
                        concept: "Un mediu pentru gândire",
                        desc: "Viziunea lui Alan Kay despre un computer personal pentru copii. El vedea interfața nu ca un panou de control, ci ca un mediu creativ pentru gândire.",
                        val: 15 
                    },
                    { 
                        id: "PKG - Graf de cunoaștere", 
                        group: "Concept", 
                        year: "2019",
                        concept: "Cunoaștere Personală Structurată",
                        desc: "Dincolo de structura cu foldere și fișiere sau simple elemente și relații, un grafic în care entitățile (oameni, idei, evenimente) sunt legate prin relațiile lor specifice complexe, în perspectivă personală.",
                        val: 22 
                    },
                    { 
                        id: "Obsidian", 
                        group: "System", 
                        year: "2020",
                        concept: "Gândire conectată",
                        desc: "Un instrument contemporan de tip PKMs, popularizat, între altele, pentru implementarea digitală a sistemului Zettelkasten, oferind grafice locale și generale dinamice, spațiu grafic infinit de lucru, note interconectate, toate acestea puternic configurabile.",
                        val: 12 
                    }
                ],
                links: [
                    { source: "Memex", target: "Augmentarea gândirii" },
                    { source: "Gândire vizuală", target: "Codare duală" },
                    { source: "Augmentarea gândirii", target: "Dynabook" },
                    { source: "Zettelkasten", target: "PKG - Graf de cunoaștere" },
                    { source: "Gândire vizuală", target: "Dynabook" },
                    { source: "Memex", target: "Zettelkasten" },
                    { source: "Dynabook", target: "Obsidian" },
                    { source: "Zettelkasten", target: "Obsidian" },
                    { source: "Obsidian", target: "PKG - Graf de cunoaștere" },
                    { source: "Obsidian", target: "Gândire vizuală" },
                    { source: "Obsidian", target: "Codare duală" },
                    { source: "Obsidian", target: "Augmentarea gândirii" },
                    { source: "PKG - Graf de cunoaștere", target: "Gândire vizuală" }
                ]
            };

            const colors = {
                "System": "#c9aa72", // Darker Gold (Cubes)
                "Concept": "#fcdb9e" // Lighter Gold (Spheres)
            };

            // --- Helper: Convert HEX to RGBA ---
            function hexToRgba(hex, alpha) {
                // Remove '#' if present
                hex = hex.replace('#', '');
                
                // Parse r, g, b
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);

                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            // --- 2. Initialize 3D Graph ---
            const Graph = ForceGraph3D()
                (document.getElementById('3d-graph'))
                .graphData(graphData)
                .nodeLabel('id')
                .nodeColor(node => colors[node.group] || "#ffffff")
                .nodeVal('val')
                .linkColor(() => 'rgba(255,255,255,0.7)') 
                .linkWidth(1)
                .backgroundColor('rgba(0,0,0,0)') 
                
                // Node Interaction
                .onNodeClick(node => {
                    // CHANGED: Increased distance from 40 to 120
                    const distance = 120;
                    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

                    Graph.cameraPosition(
                        { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                        node,
                        3000
                    );
                    showInfoCard(node);
                })
                .linkDirectionalParticles(2)
                .linkDirectionalParticleWidth(2);

            // --- 3. Custom 3D Objects with LABELS ---
            Graph.nodeThreeObject(node => {
                const group = new THREE.Group();
                let geometry;
                
                // 1. Create the Shape
                if (node.group === "System") {
                    geometry = new THREE.BoxGeometry(node.val, node.val, node.val);
                } else {
                    geometry = new THREE.SphereGeometry(node.val / 2, 32, 32);
                }

                const material = new THREE.MeshLambertMaterial({ 
                    color: colors[node.group] || "#ffffff",
                    transparent: true,
                    opacity: 0.95
                });
                const mesh = new THREE.Mesh(geometry, material);
                group.add(mesh);

                // 2. Create the Label Sprite
                const labelSprite = createTextSprite(node.id);
                labelSprite.position.set(0, 0, 0);
                group.add(labelSprite);

                return group;
            });

            // --- Helper Function: Create Text Sprite ---
            function createTextSprite(text) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // High resolution for sharpness
                const fontSize = 60; 
                const font = `bold ${fontSize}px Arial`;
                ctx.font = font;

                // Word Wrap Logic (Split into 2 lines if needed)
                const words = text.split(' ');
                let lines = [];
                if (words.length >= 2 && text.length > 10) {
                     // Simple heuristic: split in half
                     const mid = Math.ceil(words.length / 2);
                     const line1 = words.slice(0, mid).join(' ');
                     const line2 = words.slice(mid).join(' ');
                     lines = [line1, line2];
                } else {
                    lines = [text];
                }

                // Measure width to size canvas
                let maxWidth = 0;
                lines.forEach(line => {
                    const w = ctx.measureText(line).width;
                    if(w > maxWidth) maxWidth = w;
                });

                // Set Canvas Dimensions
                const lineHeight = fontSize * 1.1;
                const padding = 20;
                canvas.width = maxWidth + padding * 2;
                canvas.height = lines.length * lineHeight + padding * 2;

                // Draw Text
                ctx.font = font; // Reset font after resize
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                ctx.shadowColor = "rgba(0,0,0,0.8)";
                ctx.shadowBlur = 4;
                ctx.lineWidth = 3;
                
                const centerX = canvas.width / 2;
                const startY = (canvas.height / 2) - ((lines.length - 1) * lineHeight) / 2;

                lines.forEach((line, i) => {
                    ctx.fillText(line, centerX, startY + (i * lineHeight));
                });

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture, 
                    transparent: true,
                    depthTest: false, 
                    depthWrite: false 
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.renderOrder = 999; 

                // SCALE: 30% of original size
                const pixelToWorld = 0.045; 
                sprite.scale.set(canvas.width * pixelToWorld, canvas.height * pixelToWorld, 1);
                
                return sprite;
            }

            // --- 4. Animation & UI Logic ---
            let isRotating = true;
            let angle = 0;
            const distance = 500;

            function animate() {
                if (isRotating) {
                    angle += 0.001;
                    Graph.cameraPosition({
                        x: distance * Math.sin(angle),
                        z: distance * Math.cos(angle)
                    });
                }
                requestAnimationFrame(animate);
            }
            animate();

            // --- Global Control Functions ---
            
            // Toggle Header Logic (Minimize/Maximize)
            window.toggleHeader = function() {
                const panel = document.getElementById('header-panel');
                const minimized = document.getElementById('header-minimized');
                
                if (panel.classList.contains('hidden')) {
                    panel.classList.remove('hidden');
                    minimized.classList.add('hidden');
                    minimized.classList.remove('flex'); 
                } else {
                    panel.classList.add('hidden');
                    minimized.classList.remove('hidden');
                    minimized.classList.add('flex'); 
                }
            };

            // Close Info Card Logic (X Button)
            window.closeInfoCard = function() {
                const card = document.getElementById('info-card');
                card.classList.remove('translate-x-0', 'opacity-100');
                card.classList.add('translate-x-[-120%]', 'opacity-0');
            };

            window.toggleRotation = function() {
                isRotating = !isRotating;
            };

            window.resetCamera = function() {
                Graph.cameraPosition({ x: 0, y: 0, z: distance }, { x: 0, y: 0, z: 0 }, 2000);
                closeInfoCard();
                isRotating = true;
            };

            window.showInfoCard = function(node) {
                const card = document.getElementById('info-card');
                
                document.getElementById('card-title').innerText = node.id;
                
                // --- HEX TO RGBA COLOR FIX ---
                // CHANGED: Increased from 0.2 to 0.35 (35%)
                const originalColor = colors[node.group];
                const rgbaColor = hexToRgba(originalColor, 0.35); 
                
                const yearBadge = document.getElementById('card-year');
                yearBadge.innerText = node.year;
                yearBadge.style.backgroundColor = rgbaColor;
                // Removed 'opacity-80' from the HTML class so text is 100% white
                
                document.getElementById('card-concept').innerText = node.concept;
                document.getElementById('card-desc').innerText = node.desc;

                const connectionsDiv = document.getElementById('card-connections');
                connectionsDiv.innerHTML = '';
                
                const linkedNodes = [];
                graphData.links.forEach(link => {
                    const s = link.source.id || link.source;
                    const t = link.target.id || link.target;
                    if (s === node.id) linkedNodes.push(t);
                    if (t === node.id) linkedNodes.push(s);
                });

                linkedNodes.forEach(nName => {
                    const tag = document.createElement('button');
                    tag.className = "text-[10px] border border-gray-600 px-2 py-1 rounded-full text-gray-300 bg-gray-800/50 hover:bg-blue-600 hover:text-white hover:border-blue-400 transition-colors cursor-pointer";
                    tag.innerText = nName;
                    
                    tag.onclick = () => {
                        const targetNode = graphData.nodes.find(n => n.id === nName);
                        if (targetNode) {
                            // Also update click distance here for consistency
                            const distance = 120;
                            const distRatio = 1 + distance/Math.hypot(targetNode.x, targetNode.y, targetNode.z);

                            Graph.cameraPosition(
                                { x: targetNode.x * distRatio, y: targetNode.y * distRatio, z: targetNode.z * distRatio },
                                targetNode,
                                3000
                            );
                            showInfoCard(targetNode);
                        }
                    };

                    connectionsDiv.appendChild(tag);
                });

                card.classList.remove('translate-x-[-120%]', 'opacity-0');
                card.classList.add('translate-x-0', 'opacity-100');
                isRotating = false;
            };
        });
    </script>
</body>
</html>

